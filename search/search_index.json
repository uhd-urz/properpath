{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"<p>An opinionated OS-path module for people who take paths too seriously. <code>ProperPath</code>, as a subclass of Python's popular  <code>pathlib.Path</code>, is a drop-in replacement with some extra features. The added features/APIs are mainly aimed at improving developer experience in building CLI tools/applications. <code>ProperPath</code> was originally created for elAPI.</p> <p> </p>"},{"location":"#main-features-in-a-nutshell","title":"Main Features in a Nutshell","text":"<ol> <li>A drop-in <code>pathlib.Path</code> replacement with more descriptive REPL representation</li> <li>Built-in error logging for raised exceptions</li> <li>Simplified APIs for working with files and directories</li> <li>Better <code>platformfirs</code> integration</li> <li>Validation for file/directory write permission</li> <li>Support for Pydantic validation    and Rich pretty-repr printing</li> </ol>"},{"location":"#installation","title":"Installation","text":"<p>Make sure your Python virtual environment is activated. <code>properpath</code> requires Python 3.12 and above. Install <code>properpath</code> with <code>pip</code>.</p> <pre><code>pip install properpath\n</code></pre> <p>You can install with <code>uv</code> as well.</p> <pre><code>uv add properpath\n</code></pre>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Open a Python REPL and try the following:</p> Python REPL<pre><code>&gt;&gt;&gt; from properpath import P # \"P\" is a shorthand for \"ProperPath\"\n\n&gt;&gt;&gt; P(\"~\")\nProperPath(path=/Users/username, actual=('~',), kind=dir, exists=True, is_symlink=False, err_logger=&lt;RootLogger root (WARNING)&gt;)\n</code></pre> <p>There's also Pydantic and Rich-pretty-printing support. If you already have a script or a project where you've used <code>from pathlib import Path</code>, and if you're feeling adventurous (!), try the following:</p> <pre><code>from properpath import P as Path\n</code></pre> <p>Head over to the Tutorial page for more hands-on examples.</p>"},{"location":"integrations/","title":"Integrations","text":""},{"location":"integrations/#working-with-pydantic","title":"Working with Pydantic","text":"<p><code>ProperPath</code> can be used with Pydantic models or fields the same way <code>pathlib.Path</code> can be.</p> try_with_pydantic.py<pre><code>from pydantic import BaseModel\n\nfrom properpath import P\n\n\nclass ConfigSource(BaseModel):\n    local_path: P\n    system_path: P\n\n\nconfig_source = ConfigSource(\n    local_path=\"~/.config/app.toml\", system_path=\"/etc/app.toml\"\n)\nprint(config_source)\n# Prints: ConfigSource(local_path=ProperPath(path=/Users/culdesac/.config/app.toml, actual=('~/.config/app.toml',), kind=file, exists=False, is_symlink=False, err_logger=&lt;RootLogger root (WARNING)&gt;), system_path=ProperPath(path=/etc/app.toml, actual=('/etc/app.toml',), kind=file, exists=False, is_symlink=False, err_logger=&lt;RootLogger root (WARNING)&gt;))\n</code></pre>"},{"location":"integrations/#rich-pretty-printing-in-repl","title":"Rich pretty-printing in REPL","text":"<p>If <code>rich</code> is installed (can optionally be installed with <code>properpath[rich]</code>), <code>ProperPath</code> instances will be pretty-printed in REPL. Make sure <code>from rich import pretty; pretty.install()</code> is run in the REPL beforehand, or added to the <code>PYTHONSTARTUP</code> script.</p> <p><pre><code>&gt;&gt;&gt; from rich import pretty; pretty.install()\n&gt;&gt;&gt; config_source  # from the example before \n</code></pre> </p>"},{"location":"tutorial/","title":"Tutorial","text":"<p>In the examples below, we will use the shorthand <code>P</code>: <code>from properpath import P</code>, instead of <code>from properpath import ProperPath</code>, where <code>P == ProperPath</code>. That is because <code>P</code> is much shorter and easier to type, and makes working with paths on the REPL more enjoyable.</p>"},{"location":"tutorial/#drop-in-pathlibpath-replacement","title":"Drop-in <code>pathlib.Path</code> replacement","text":"<p>Since <code>ProperPath</code> is a subclass of <code>pathlib.Path</code> it supports all the methods and attributes supported by <code>pathlib.Path</code>. We can pass a <code>pathlib.Path</code> instance or a string path or multiple path segments or <code>os.path</code> values to <code>ProperPath</code>.</p> Python REPL<pre><code>&gt;&gt;&gt; from properpath import P\n&gt;&gt;&gt; p = P(\"~/foo\")\n&gt;&gt;&gt; p\nProperPath(path=/Users/username/foo, actual=('~/foo',), kind=dir, exists=False, is_symlink=False, err_logger=&lt;RootLogger root (WARNING)&gt;)\n&gt;&gt;&gt; isinstance(p, pathlib.Path)\nTrue\n&gt;&gt;&gt; P.home()  # pathlib.Path's method\nProperPath(path=/Users/username, actual=('/Users/username',), kind=dir, exists=True, is_symlink=False, err_logger=&lt;RootLogger root (WARNING)&gt;)\n</code></pre> <p><code>ProperPath</code> shows more information about the path on the REPL (or a  <code>repr</code> call from inside a script). Notice, how <code>ProperPath</code> always expands the username (<code>~</code>) segment by default. A <code>ProperPath</code> instance can also be passed to <code>pathlib.Path</code> or <code>os.path</code> methods.</p> Python REPL<pre><code>&gt;&gt;&gt; from pathlib import Path\n\n&gt;&gt;&gt; Path(P(\"~\"))\nPosixPath('/Users/username')\n</code></pre>"},{"location":"tutorial/#is-a-file-or-a-dir","title":"Is a <code>file</code> or a <code>dir</code>?","text":"<p>A <code>ProperPath</code> instance stores whether the path is a file or a directory in the <code>kind</code> attribute. If the path doesn't exist beforehand, <code>PropePath</code> will try to assume it from the path's extension. <code>ProperPath</code> also knows how to handle special files like <code>/dev/null</code>.</p> Python REPL<pre><code>&gt;&gt;&gt; p = P(\"~/foo.txt\")\n&gt;&gt;&gt; p.exists()\nFalse\n&gt;&gt;&gt; p.kind  # Kind is determined from the file extension.\n'file'\n&gt;&gt;&gt; p = P(\"~/foo\")\n&gt;&gt;&gt; p.exists()\nTrue\n&gt;&gt;&gt; p.kind\n'dir'\n</code></pre> <p>In this code block though we could just use <code>is_dir()</code>. The real power of <code>kind</code> comes when we're working with files/directories that aren't strictly created or handled by us, but we know what <code>kind</code> we are expecting. When <code>kind</code> attribute is modified by the developer, the <code>kind</code> is treated as the developer-expected <code>kind</code>. When <code>kind</code> is not modified, <code>ProperPath</code> determines the appropriate <code>kind</code>. We can modify <code>kind</code> by passing it as an argument to the constructor during the path instance creation, or later on by simply updating the value of the attribute <code>p.kind = \"&lt;file or dir&gt;\"</code>. Pure <code>ProperPath</code> operations will expect that <code>kind</code> for all future operations. This can help catch unexpected errors or even prevent unexpected file operation. An example: Let's consider a situation where we expect a file named <code>foo</code> to exist in user's <code>~/Downloads</code> folder. But for whatever reason, a directory with the exact the same name already exists in <code>~/Downloads</code>. If we want to create the file with <code>pathlib.Path(\"~/Downloads/foo\").expanduser().touch(exist_ok=True)</code>, the method will succeed, and we will have assumed a file was indeed created! <code>ProperPath</code>'s <code>create</code> method will use <code>kind</code> to find out the mismatch in expectation, and throw an error.</p> Python REPL<pre><code>&gt;&gt;&gt; q = P(\"~/Downloads\", \"foo\", kind=\"file\")\nProperPath(path=/Users/username/Downloads/foo, actual=('/Users/username/Downloads/foo',), kind=file, exists=True, is_symlink=False, err_logger=&lt;RootLogger root (WARNING)&gt;)\n&gt;&gt;&gt; q.create()\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"/Users/username/Workshop/properpath/src/properpath/properpath.py\", line 441, in create\n    raise e\n  File \"/Users/username/Workshop/properpath/src/properpath/properpath.py\", line 421, in create\n    raise is_a_dir_exception(message)\nIsADirectoryError: File was expected but a directory with the same name was found: PATH=/Users/username/Downloads from SOURCE=('~/Downloads', 'foo').\n</code></pre> <p>Summary</p> <p>In short, when we don't modify the <code>kind</code> attribute, <code>kind</code> simply gives the path's  <code>is_file()</code> or  <code>is_dir()</code> status. When we do modify the attribute, our modified <code>kind</code> is cached, and is treated as the expected <code>kind</code> for all future operations. When this expected <code>kind</code> doesn't match the actual <code>kind</code> of the path in the system for whatever reason,  <code>ProperPath</code> will attempt to throw an error before irrecoverable operations like deleting files.</p>"},{"location":"tutorial/#built-in-error-logging","title":"Built-in error logging","text":"<p>A custom logger can be passed to <code>ProperPath</code> instance. This logger will be used throughout path operations for that path instance. If no logger is passed, <code>ProperPath</code> will use <code>P.default_err_logger</code> class attribute (which by default is the Python root logger).</p> Python REPL<pre><code>&gt;&gt;&gt; import logging\n&gt;&gt;&gt; logging.basicConfig(level=logging.DEBUG)\n&gt;&gt;&gt; p = P(\"/var/log/my_app.log\")\n&gt;&gt;&gt; with p.open(\"w\") as f:\n...     f.write(\"Hello, world!\")\n...\nDEBUG:root:Could not open file PATH=/private/var/log/my_app.log from SOURCE=('/var/log/my_app.log',). \nException: PermissionError(13, 'Permission denied')\nTraceback (most recent call last):\n  File \"&lt;python-input-4&gt;\", line 1, in &lt;module&gt;\n    with p.open(\"w\") as f:\n         ~~~~~~^^^^^\n# Any exception raised during path operations will be logged to the new_logger, \n# before being raised.\n</code></pre> <p>Note</p> <p>All log messages are logged as <code>DEBUG</code> messages. So the default logging level or handler level should be set to <code>DEBUG</code>. This is so that path logs don't overwhelm the regular users, and the <code>DEBUG</code> level is only set for debugging/development. </p> <p>We can also pass our own custom logger to <code>P(\"/var/log/my_app.log\", err_logger=logging.getLogger(\"my_logger\"))</code>, or modify the <code>err_logger</code> attribute at runtime. Each logger is tied to the instance it was passed to. If we want to have a single logger to be shared with all instances of <code>ProperPath</code>, we just set the class attribute <code>P.default_err_logger = logging.getLogger(\"my_logger\")</code>.</p>"},{"location":"tutorial/#create-and-remove-paths","title":"<code>create</code> and <code>remove</code> paths","text":"<p>To create a new file or directory, <code>pathlib.Path</code> would require a boilerplate <code>if path.is_file():</code> or <code>if path.is_dir():</code> block if the path is unknown. <code>ProperPath</code> provides the <code>create</code> method that simplifies this step. Just call <code>create</code> on any path to create it. If the path already exists, nothing happens.</p> <pre><code>P(\"/etc/my_app/config.toml\").create()\n</code></pre> <p>Similarly, the <code>remove</code> removes the need to boilerplate check for if the path is a file or a directory, or if it is empty or not. If the path is a directory, everything inside it will be removed recursively by default. <code>remove</code> method accepts a <code>parent_only</code> argument, which if <code>True</code>, will only remove the top-level contents only (i.e., will remove only the files, will not do a recursion into other directories).</p> <pre><code>.local/\n\u251c\u2500 share/\n\u2502  \u251c\u2500 my_app/\n\u2502  \u2502  \u251c\u2500 custom/\n\u2502  \u2502  \u2502  \u251c\u2500 plugins/\n\u2502  \u2502  \u251c\u2500 config.toml\n</code></pre> <pre><code>P(\"~/.local/share/my_app/\").remove(parent_only=True)\n</code></pre> <p>The code above will only <code>~/.local/share/my_app/config.toml</code>, and leave <code>custom/</code> and <code>plugins/</code> directories as is. If <code>parents_only=False</code> is passed (the default), everything inside <code>my_app</code> directory will be deleted recursively. Under the hood both <code>create</code> and <code>remove</code> methods take advantage of the <code>kind</code> attribute.</p>"},{"location":"tutorial/#better-platformdirs","title":"Better Platformdirs","text":"<p><code>ProperPath</code> comes integrated with a popular library used for managing common application paths: platformdirs. E.g., to get OS-standard locations for configuration files, logs, caches, etc. See platformdirs documentation for more details and examples for other operating systems. Values from <code>platformdirs</code> by default are strings. But with <code>P.platformdirs</code>, you can get <code>ProperPath</code> instances instead.</p> Python REPL<pre><code>&gt;&gt;&gt; from properpath import P\n&gt;&gt;&gt; app_dirs = P.platformdirs(\"my_app\", \"my_org\")\n&gt;&gt;&gt; app_dirs.user_config_dir\nProperPath(path=/Users/username/Library/Application Support/my_app, actual=('/Users/username/Library/Application Support/my_app',), kind=dir, exists=False, is_symlink=False, err_logger=&lt;RootLogger root (WARNING)&gt;)\n&gt;&gt;&gt; app_dirs.user_data_dir\nProperPath(path=/Users/username/Library/Application Support/my_app, actual=('/Users/username/Library/Application Support/my_app',), kind=dir, exists=False, is_symlink=False, err_logger=&lt;RootLogger root (WARNING)&gt;)\n&gt;&gt;&gt; app_dirs.user_cache_dir\nProperPath(path=/Users/username/Library/Caches/my_app, actual=('/Users/username/Library/Caches/my_app',), kind=dir, exists=False, is_symlink=False, err_logger=&lt;RootLogger root (WARNING)&gt;)\n&gt;&gt;&gt; app_dirs.site_data_dir\nProperPath(path=/Library/Application Support/my_app, actual=('/Library/Application Support/my_app',), kind=dir, exists=False, is_symlink=False, err_logger=&lt;RootLogger root (WARNING)&gt;)\n&gt;&gt;&gt; app_dirs.site_config_dir\nProperPath(path=/Library/Application Support/my_app, actual=('/Library/Application Support/my_app',), kind=dir, exists=False, is_symlink=False, err_logger=&lt;RootLogger root (WARNING)&gt;)\n&gt;&gt;&gt; app_dirs.user_documents_dir\nProperPath(path=/Users/username/Documents, actual=('/Users/username/Documents',), kind=dir, exists=True, is_symlink=False, err_logger=&lt;RootLogger root (WARNING)&gt;)\n&gt;&gt;&gt; app_dirs.user_downloads_dir\nProperPath(path=/Users/username/Downloads, actual=('/Users/username/Downloads',), kind=dir, exists=True, is_symlink=False, err_logger=&lt;RootLogger root (WARNING)&gt;)\n&gt;&gt;&gt;  # Etc. See whole list: https://github.com/tox-dev/platformdirs?tab=readme-ov-file#platformdirs-for-convenience\n</code></pre> <p>Platformdirs enforces a strict directory structure for macOS, but many tools out there follow the Unix-style directory structures on macOS as well. <code>ProperPath</code> provides an additional <code>follow_unix</code> argument to <code>ProperPath.platformdirs</code> that will enforce Unix-style directory structure on macOS, but will leave Windows as is.</p> Python REPL<pre><code>&gt;&gt;&gt; app_dirs = P.platformdirs(\"my_app\", \"my_org\", follow_unix=True)\n&gt;&gt;&gt; app_dirs.user_config_dir\nProperPath(path=/Users/username/.config/my_app, actual=('/Users/username/.config/my_app',), kind=dir, exists=False, is_symlink=False, err_logger=&lt;RootLogger root (WARNING)&gt;)\n&gt;&gt;&gt; app_dirs.user_data_dir\nProperPath(path=/Users/username/.local/share/my_app, actual=('/Users/username/.local/share/my_app',), kind=dir, is_symlink=False, exists=False, err_logger=&lt;RootLogger root (WARNING)&gt;)\n&gt;&gt;&gt; app_dirs.user_cache_dir\nProperPath(path=/Users/username/.cache/my_app, actual=('/Users/username/.cache/my_app',), kind=dir, exists=False, is_symlink=False, err_logger=&lt;RootLogger root (WARNING)&gt;)\n&gt;&gt;&gt; app_dirs.site_data_dir\nProperPath(path=/usr/local/share/my_app, actual=('/usr/local/share/my_app',), kind=dir, exists=False, is_symlink=False, err_logger=&lt;RootLogger root (WARNING)&gt;)\n&gt;&gt;&gt; app_dirs.site_config_dir\nProperPath(path=/etc/xdg/my_app, actual=('/etc/xdg/my_app',), kind=dir, exists=False, is_symlink=False, err_logger=&lt;RootLogger root (WARNING)&gt;)\n&gt;&gt;&gt; app_dirs.user_documents_dir\nProperPath(path=/Users/username/Documents, actual=('/Users/username/Documents',), kind=dir, exists=True, is_symlink=False, err_logger=&lt;RootLogger root (WARNING)&gt;)\n&gt;&gt;&gt; app_dirs.user_downloads_dir\nProperPath(path=/Users/username/Downloads, actual=('/Users/username/Downloads',), kind=dir, exists=True, is_symlink=False, err_logger=&lt;RootLogger root (WARNING)&gt;)\n</code></pre>"},{"location":"tutorial/#path-validation","title":"Path validation","text":"<p>We often write to files, so we need to make sure if the file we're writing to is even writable; i.e., if the file exists, if there is enough storage space, if there is sufficient permission, etc. <code>ProperPath</code> comes with a <code>PathWriteValidator</code> class that can be used to do exactly that. Example: we want to write to a file from a list of fallback files, and we want to write to the first one that works.</p> validate.py<pre><code>from properpath.validators import PathValidationError, PathWriteValidator\n\nuser_desired_paths = [\"/usr/usb/Downloads/\", \"~/Downloads\"]\n# PathWriteValidator will convert the strings to ProperPath instances during validation.\ntry:\n    validated_path = PathWriteValidator(user_desired_paths).validate()\nexcept PathValidationError as e:\n    # PathValidationError is raised when all paths fail validation.\n    raise e(\"None of the paths are writable.\")\nelse:\n    validated_path.write_text(\"Hooray!\")\n</code></pre> <p>Of course, a single path can also be passed to <code>PathWriteValidator</code>.</p> <p><code>ProperPath</code> comes with a <code>PathException</code> attribute that stores any exception raised during any path operation. In other words, an error raised for a path is tied to that path only. We can use this <code>PathException</code> to implement a fallback mechanism. I.e., if we want to just forget about the error from one path, and move onto the next path. From one of our previous examples:</p> try_path_exception.py<pre><code>p = P(\"~/Downloads/metadata.txt\")\n\ntry:\n    with p.open(\"w\") as f:\n        f.write(\"Hello, world!\")\nexcept p.PathException as e:\n    # try a different path\n    p.err_logger.warning(f\"Failed to write to {p}. OS-error code: {e.errno}. Exception: {e!r}\")\n    p.err_logger.info(\"Trying another path...\")\n    P(\"~/metadata.txt\").write_text(\"Hello, world!\")\n</code></pre> <p>In some ways, <code>PathException</code> treats errors as values.</p>"},{"location":"apis/properpath/","title":"<code>ProperPath</code>","text":""},{"location":"apis/properpath/#properpath.NoException","title":"NoException","text":"<p>               Bases: <code>Exception</code></p> <p>NoException works as an exception placeholder only. It is used as the default value of PathException.</p> Source code in <code>src/properpath/properpath.py</code> <pre><code>class NoException(Exception):\n    \"\"\"\n    NoException works as an exception placeholder only.\n    It is used as the default value of PathException.\n    \"\"\"\n</code></pre>"},{"location":"apis/properpath/#properpath.ProperPath","title":"ProperPath","text":"<p>               Bases: <code>Path</code></p> <p>A <code>pathlib.Path</code> subclass that is a drop-in replacement for the <code>pathlib.Path</code> module.</p> <p><code>ProperPath</code> provides additional features such as custom logging for errors, automatic user expansion, information-rich repr, and the ability to create and remove files/directories without having to know their type.</p> Example <pre><code>from properpath import ProperPath\n\npath1 = ProperPath(\"~/Downloads\")\nrepr(path1)\n# Prints: ProperPath(path=/Users/culdesac/Downloads, actual=('~/Downloads',),\nkind=dir, exists=True, err_logger=&lt;RootLogger root (WARNING)&gt;)\n</code></pre> <p>Attributes:</p> Name Type Description <code>default_err_logger</code> <code>Logger</code> <p>The default logger instance shared between all instances of <code>ProperPath</code> when no custom logger <code>err_logger</code> is provided to an instance.</p> Source code in <code>src/properpath/properpath.py</code> <pre><code>class ProperPath(Path):\n    \"\"\"\n    A `pathlib.Path` subclass that is a drop-in replacement for the `pathlib.Path` module.\n\n    `ProperPath` provides additional features such as custom logging for errors,\n    automatic user expansion, information-rich repr, and the ability to create and remove\n    files/directories without having to know their type.\n\n    Example:\n        ```python\n        from properpath import ProperPath\n\n        path1 = ProperPath(\"~/Downloads\")\n        repr(path1)\n        # Prints: ProperPath(path=/Users/culdesac/Downloads, actual=('~/Downloads',),\n        kind=dir, exists=True, err_logger=&lt;RootLogger root (WARNING)&gt;)\n        ```\n\n    Attributes:\n        default_err_logger (logging.Logger): The default logger instance shared between all instances of `ProperPath` when no custom\n            logger `err_logger` is provided to an instance.\n    \"\"\"\n\n    default_err_logger: logging.Logger = logging.getLogger()\n\n    def __init__(\n        self,\n        *actual: Union[str, Path, \"ProperPath\"],\n        kind: Optional[str] = None,  # Here, None =&gt; Undefined/unknown\n        err_logger: Optional[logging.Logger] = None,\n    ):\n        \"\"\"\n        Initializes a `ProperPath` instance. A `ProperPath` instance can be passed to `pathlib.Path` and vice versa.\n\n        Args:\n            actual (Union[str, Path, \"ProperPath\"]): A collection of paths provided as strings, `Path` objects,\n                or `ProperPath` objects that represent the input paths to be processed.\n                This acts just like the first argument passed to `pathlib.Path`.\n                E.g., `ProperPath(\"~\", \"foo\")`.\n\n        Keyword Args:\n            kind (Optional[str]): An optional string to indicate if the path is a file or a directory. If it is `None` (the default),\n                ProperPath will try to determine the kind automatically based on file suffixes and various other patterns.\n            err_logger (Optional[logging.Logger]): An optional `Logger` object for handling error logging.\n                If `None`, the class instance default_err_logger is used.\n        \"\"\"\n\n        self._user_expects_kind: bool\n        self._kind: Literal[\"file\", \"dir\"] | None\n        self.actual = actual\n        super().__init__(self._expanded)\n        self.kind = kind\n        self.err_logger = err_logger or ProperPath.default_err_logger\n        self.PathException = NoException\n\n    @classmethod\n    def platformdirs(\n        cls,\n        appname: Optional[str] = None,\n        appauthor: str | Literal[False] | None = None,\n        version: Optional[str] = None,\n        roaming: bool = False,\n        multipath: bool = False,\n        opinion: bool = True,\n        ensure_exists: bool = False,\n        follow_unix: bool = False,\n    ) -&gt; ProperPlatformDirs:\n        \"\"\"\n        Initializes and returns a `platformdirs.PlatformDirs` instance.\n\n        Provides appropriate platform-specific application directories (e.g., OS-standard\n        location for configuration files, logs, shared files, caches, etc.).\n        See platformdirs documentation for more details: https://github.com/tox-dev/platformdirs\n\n        platformdirs doesn't offer a way to get Unix-like directories on macOS which may not\n        be always desired. So, `ProperPath.platformdirs` offers an additional argument\n        `follow_unix`, which is False by default. If `follow_unix` is True,\n        `ProperPath.platformdirs` will return an instance that follows a Unix-like directory\n        structure for both macOS and Linux-based operating systems. Windows paths will not\n        be altered.\n\n\n        Example:\n            ```python  hl_lines=\"3 8 13\"\n            app_dirs = ProperPath.platformdirs(\"MyApp\", \"MyOrg\")\n            app_dirs.user_data_dir\n            # Returns ProperPath('/Users/user/Library/Application Support/MyApp')\n\n            # Use Unix-like paths on macOS\n            app_dirs = ProperPath.platformdirs(\"MyApp\", follow_unix=True)\n            app_dirs.user_data_dir\n            # Returns a Unix-style path even on macOS: ProperPath('/home/user/.local/share/MyApp\n\n            # With additional arguments for platformdirs.PlatformDirs\n            dirs = ProperPath.platformdirs(\"MyApp\", version=\"1.0\", roaming=True)\n            dirs.user_config_dir\n            # Returns ProperPath('/Users/user/Library/Application Support/MyApp/1.0')\n            ```\n\n        Args:\n            appname (Optional[str]): The name of the app author or distributing body for this application.\n            appauthor (str | Literal[False] | None): Typically, it is the owning company name. Defaults to `appname`.\n                You may pass ``False`` to disable it.\n            version (Optional[str]): An optional version path element to append to the path.\n                You might want to use this if you want multiple versions of your app to be\n                able to run independently. If used, this would typically be ``&lt;major&gt;.&lt;minor&gt;``.\n            roaming (bool): Whether to use the roaming appdata directory on Windows.\n                That means that for users on a Windows network setup for roaming profiles,\n                this user data will be synced on login.\n                See: https://technet.microsoft.com/en-us/library/cc766489(WS.10).aspx\n            multipath (bool): An optional parameter which indicates that the entire list of data\n                dirs should be returned. By default, the first item would only be returned.\n            opinion (bool): A flag to indicating to use opinionated values.\n            ensure_exists (bool): Optionally create the directory (and any missing parents) upon\n                access if it does not exist. By default, no directories are created.\n            follow_unix (bool): Specifies whether to enforce a Unix-like directory structure\n                for both macOS and Linux. Defaults to False.\n\n        Returns:\n            (PlatformDirs): An instance of the appropriate platform directory handler\n        \"\"\"\n\n        dirs: ProperPlatformDirs | ProperUnix\n        if follow_unix is True:\n            if sys.platform == \"darwin\":\n                dirs = ProperUnix(\n                    appname,\n                    appauthor,\n                    version,\n                    roaming,\n                    multipath,\n                    opinion,\n                    ensure_exists,\n                    path_cls=cls,\n                )\n            else:\n                dirs = ProperPlatformDirs(\n                    appname,\n                    appauthor,\n                    version,\n                    roaming,\n                    multipath,\n                    opinion,\n                    ensure_exists,\n                    path_cls=cls,\n                )\n        else:\n            dirs = ProperPlatformDirs(\n                appname,\n                appauthor,\n                version,\n                roaming,\n                multipath,\n                opinion,\n                ensure_exists,\n                path_cls=cls,\n            )\n        return dirs\n\n    def __str__(self):\n        return str(self._expanded)\n\n    def __repr__(self):\n        \"\"\"\n        Returns:\n            (str): An information-rich representation of the ProperPath instance.\n        \"\"\"\n        return (\n            f\"{self.__class__.__name__}(path={self}, actual={self.actual}, \"\n            f\"kind={self.kind}, exists={self.exists()}, is_symlink={self.is_symlink()}, \"\n            f\"err_logger={self.err_logger})\"\n        )\n\n    def __rich_repr__(self):\n        \"\"\"\n        Enables rich __repr__ support.\n        See [rich REPR protocol documentation](https://rich.readthedocs.io/en/latest/pretty.html#rich-repr-protocol).\n        \"\"\"\n        yield \"path\", str(self)\n        yield \"actual\", self.actual\n        yield \"kind\", self.kind\n        yield \"exists\", self.exists()\n        yield \"is_symlink\", self.is_symlink()\n        yield \"err_logger\", self.err_logger\n\n    def __hash__(self):\n        return super().__hash__()\n\n    def __deepcopy__(self, memo):\n        \"\"\"\n        `ProperPath`, likely due to being a victim of inheritance hell, can throw odd errors when it is deepcopied\n        as a namedtuple. The `__deepcopy__` method is overridden to avoid that.\n\n        Note:\n            If you're getting `AttributeError: 'properpath.properpath.ProperPath' object has no attribute '_raw_paths'.\n            Did you mean: '_raw_path'?`, it likely has something to do with `__deepcopy__` even if\n            it doesn't show up in the traceback.\n\n        Args:\n            memo:\n        \"\"\"\n        if memo_instance := memo.get(id(self)):\n            return memo_instance\n        instance = self.__class__(self)\n        memo[id(self)] = instance\n        instance.__dict__.update(deepcopy(self.__dict__, memo))\n        return instance\n\n    @classmethod\n    def __get_pydantic_core_schema__(cls, source_type: Any, handler: Any):\n        \"\"\"\n        Enables Pydantic validation support.\n        See [Pydantic documentation](https://docs.pydantic.dev/latest/concepts/types/#customizing-validation-with-__get_pydantic_core_schema__).\n        \"\"\"\n        return _get_pydantic_core_schema(cls, source_type, handler)\n\n    def __eq__(self, to):\n        return super().__eq__(to)\n\n    def __truediv__(self, other) -&gt; \"ProperPath\":\n        return ProperPath(self._expanded / other, err_logger=self.err_logger)\n\n    @property\n    def actual(self) -&gt; Iterable[str]:\n        \"\"\"\n        Provides access to the user-given path (or path segments) that was passed to the constructor of the\n        `ProperPath` instance. `ProperPath` by default expands any user indicator `\"~\"`\n        automatically and uses the expanded path for all operations. The `actual` attribute will reveal\n        the non-expanded original value.\n\n        Example:\n            ```python\n            ProperPath(\"~\", \"foo\").actual\n            # Returns (\"~\", \"foo\")\n            ```\n\n        Returns:\n            (Iterable[str]): The path value\n        \"\"\"\n        return self._actual\n\n    @actual.setter\n    def actual(self, value) -&gt; None:\n        segments = []\n        for segment in value:\n            if isinstance(\n                segment, (ProperPath, Path)\n            ):  # We want to be able to pass a ProperPath() to ProperPath()\n                segment = str(segment)\n                # If this isn't handled this way for Path instances,\n                # weird issues like \"AttributeError: object has\n                # no attribute '_raw_paths'. Did you mean: '_raw_path'?\" can happen.\n            segments.append(segment)\n        self._actual = tuple(segments)\n\n    @property\n    def err_logger(self):\n        \"\"\"\n        Provides access to the error logger that is used for logging exceptions.\n        The default logger is `ProperPath.default_err_logger`.\n\n        Returns:\n            (Logger): The error logger instance.\n        \"\"\"\n        return self._err_logger\n\n    @err_logger.setter\n    def err_logger(self, value):\n        if not isinstance(value, logging.Logger):\n            raise ValueError(\n                f\"'err_logger' must be a {logging.Logger.__name__} instance!\"\n            )\n        self._err_logger = value\n\n    # noinspection PyPep8Naming\n    @property\n    def PathException(\n        self,\n    ) -&gt; type[Exception] | type[BaseException]:\n        \"\"\"\n        `PathException` property stores an exception (like `OSException`) raised for the working path instance,\n        before the exception is raised normally. In some ways, `PathException` treats\n        errors/exceptions as values. `PathException` can be used to create design patterns where one path failing\n        doesn't matter, but any path from a list of available paths can be used for the user.\n\n        Example:\n            ```python\n            # Storing data to a file of from a list of fallback file paths:\n            path_exceptions = []\n\n            for path in [ProperPath(\"/media/usb/file.txt\"), ProperPath(\"~/Downloads/file.txt\")]:\n                try:\n                    path.write_text(\"Hello, World!\")\n                except path.PathException as e:\n                    # Ignore exception, just try the next path.\n                    # Exception is automatically logged by path.err_logger\n                    path_exceptions.append(e)\n                    continue\n                else:\n                    # Write is successful without any error, we exit the loop.\n                    break\n            else:\n                # When all paths failed, raise the last exception (or all exceptions).\n                path.err_logger.error(f\"Couldn't write to any of the fallback paths. Exceptions: {path_exceptions}\")\n                raise path.PathException\n            ```\n\n        Returns:\n            (type[Exception] | type[BaseException]): The exception thrown for the working path instance.\n        \"\"\"\n        return self._PathException\n\n    # noinspection PyPep8Naming\n    @PathException.setter\n    def PathException(self, value) -&gt; None:\n        if isinstance(value, (Exception, BaseException)):\n            self._PathException = type(value)\n        elif issubclass(value, (Exception, BaseException)):\n            self._PathException = value\n        else:\n            raise ValueError(\n                \"Only a subclass of Exception or BaseException can be \"\n                \"assigned to descriptor PathException.\"\n            )\n\n    # noinspection PyPep8Naming\n    @PathException.deleter\n    def PathException(self):\n        raise AttributeError(\"PathException cannot be deleted!\")\n\n    @property\n    def _expanded(self) -&gt; Path:\n        return Path(*self.actual).expanduser()\n\n    @_expanded.setter\n    def _expanded(self, value) -&gt; None:\n        raise AttributeError(\"Expanded is not meant to be modified.\")\n\n    @property\n    def kind(self) -&gt; Literal[\"file\", \"dir\"]:\n        \"\"\"\n        Retrieves the path kind: a \"file\" or a \"dir\".\n        If the path exists, kind already knows what kind it is. If the path doesn't exist, kind tries to assume the kind from\n        file suffixes. Kind can also handle special files like `/dev/null`. A `kind` value ('file' or 'dir') can also be\n        manually passed to the constructor during instance creation or be set later. The user-modified `kind` is treated as the\n        user expected `kind`.\n\n        Returns:\n            (Literal[\"file\", \"dir\"]): \"file\" or \"dir\" depending on the path.\n        \"\"\"\n        if self._kind is None or self._user_expects_kind is False:\n            self._kind = (\n                \"dir\"\n                if super().is_dir()\n                else \"file\"\n                if (super().is_file() or super().suffix or super().exists())\n                # self.exists() for special files like /dev/null\n                # since is_file() doesn't consider /dev/null to be a file!\n                else \"dir\"\n            )\n        return self._kind\n\n    @kind.setter\n    def kind(self, value) -&gt; None:\n        if value is None:\n            self._kind = None\n            self._user_expects_kind = False\n        else:\n            match value.lower():\n                case \"file\":\n                    self._kind = \"file\"\n                case \"dir\":\n                    self._kind = \"dir\"\n                case _:\n                    raise ValueError(\n                        f\"Invalid value '{value}' for parameter 'kind'. The following values \"\n                        \"for 'kind' are allowed: file, dir.\"\n                    )\n            self._user_expects_kind = True\n\n    @staticmethod\n    def _error_helper_compare_path_source(\n        source: Union[Path, str, Iterable[str]], target: Union[Path, str]\n    ) -&gt; str:\n        return (\n            f\"PATH={target} from SOURCE={source}\"\n            if str(source) != str(target)\n            else f\"PATH={target}\"\n        )\n\n    def create(self, verbose: bool = True) -&gt; None:\n        \"\"\"\n        Creates a file or directory based on the specified kind (file or dir). Thanks to the property `kind`,\n        the `create` method helps to avoid writing boilerplate code like `if path.is_file()`\n        or `path.is_dir()`. For files and directories, it ensures the parent directory exists\n        before creating the file. Logs operations and exceptions for debugging.\n\n        Args:\n            verbose (bool): If True, debug logs will be generated to trace creation\n                attempts for files and directories.\n\n        Raises:\n            PermissionError: If the operation lacks permission to create the file\n                or directory.\n            NotADirectoryError: If the operation attempts to create a directory\n                under a path that is incorrectly treated as a non-directory.\n            OSError: If an OS-level error (all others excluding `PermissionError` and\n                `NotADirectoryError`) occurs during the creation process.\n\n        Returns:\n            None\n        \"\"\"\n        path = super().resolve(strict=False)\n        try:\n            match self.kind:\n                case \"file\":\n                    path_parent, path_file = path.parent, path.name\n                    if not path_parent.exists() and verbose:\n                        self.err_logger.debug(\n                            f\"File {self._error_helper_compare_path_source(self.actual, path_parent)} \"\n                            f\"could not be found. An attempt to create file \"\n                            f\"{path_parent} will be made.\"\n                        )\n                    path_parent.mkdir(parents=True, exist_ok=True)\n                    (path_parent / path_file).touch(exist_ok=True)\n                    if not (path_parent / path_file).is_file():\n                        is_a_dir_exception = IsADirectoryError\n                        message = (\n                            \"File was expected but a directory with the same name was found: \"\n                            f\"{self._error_helper_compare_path_source(self.actual, path_parent)}. \"\n                        )\n                        self.err_logger.debug(message)\n                        raise is_a_dir_exception(message)\n                case \"dir\":\n                    if not path.exists() and verbose:\n                        self.err_logger.debug(\n                            f\"Directory {self._error_helper_compare_path_source(self.actual, path)} \"\n                            f\"could not be found. An attempt to create directory \"\n                            f\"{path} will be made.\"\n                        )\n                    path.mkdir(parents=True, exist_ok=True)\n        except (permission_exception := PermissionError) as e:\n            message = f\"Permission to create {self._error_helper_compare_path_source(self.actual, path)} is denied.\"\n            self.err_logger.debug(message)\n            self.PathException = permission_exception\n            raise e\n        except tuple(OSError.__subclasses__()) as e:\n            self.err_logger.debug(\n                f\"Could not create {self._error_helper_compare_path_source(self.actual, path)}. \"\n                f\"Exception: {e!r}\"\n            )\n            self.PathException = e\n            raise e\n        except (os_exception := OSError) as os_err:\n            # When an attempt to create a file or directory inside root (e.g., '/foo')\n            # is made, OS can throw OSError with error no. 30 instead of PermissionError.\n            self.err_logger.debug(\n                f\"Could not create {self._error_helper_compare_path_source(self.actual, path)}. \"\n                f\"Exception: {os_err!r}\"\n            )\n            self.PathException = os_exception\n            raise os_err\n\n    def _remove_file(\n        self, _file: Union[Path, Self, None] = None, verbose: bool = True\n    ) -&gt; None:\n        file = _file or self._expanded\n        if not isinstance(file, Path):\n            raise ValueError(\n                f\"PATH={file} is empty or isn't a valid pathlib.Path instance! \"\n                f\"Check instance attribute 'expanded'.\"\n            )\n        try:\n            file.unlink()\n        except (permission_exception := PermissionError) as e:\n            message = (\n                f\"Permission to remove {self._error_helper_compare_path_source(self.actual, file)} \"\n                f\"as a file is denied.\"\n            )\n            self.err_logger.debug(message)\n            self.PathException = permission_exception\n            raise e\n        except tuple(OSError.__subclasses__()) as e:\n            self.err_logger.debug(\n                f\"Could not remove {self._error_helper_compare_path_source(self.actual, file)}. \"\n                f\"Exception: {e!r}\"\n            )\n            self.PathException = e\n            raise e\n        except (os_exception := OSError) as e:\n            self.err_logger.debug(\n                f\"Could not remove {self._error_helper_compare_path_source(self.actual, file)}. \"\n                f\"Exception: {e!r}\"\n            )\n            self.PathException = os_exception\n            raise e\n        if verbose:\n            self.err_logger.debug(f\"Removed file: {file}\")\n\n    def remove(self, parent_only: bool = False, verbose: bool = True) -&gt; None:\n        \"\"\"\n        Removes the `ProperPath` file or directory based on the specified parameters. The method\n        removes either all contents of a directory path or a single file, depending on the type of\n        the path (file or directory). If `parent_only` is True, only top-level contents are removed\n        while keeping the parent directory intact. If `parent_only` is False, all contents are\n        removed recursively. `verbose` can be passed `False` (default is `True`) to disable logging\n        the removals.\n\n        Args:\n            parent_only (bool): A boolean flag indicating whether only the immediate children of the\n                directory should be removed, leaving the parent directory intact. Defaults to `False`.\n            verbose (bool): A boolean flag indicating whether detailed logs of the removal operations\n                should be printed or logged. Defaults to `True`.\n\n        Returns:\n            None\n        \"\"\"\n        # removes everything (if parent_only is False) found inside a ProperPath except the parent directory of the path\n        # if the ProperPath isn't a directory, then it just removes the file\n        match self.kind:\n            case \"file\":\n                self._remove_file(verbose=verbose)\n            case \"dir\":\n                ls_ref: Iterable[Path]\n                ls_ref = (\n                    super().glob(r\"**/*\") if not parent_only else super().glob(r\"*\")\n                )\n                ls_ref = list(ls_ref)\n                if ls_ref:\n                    for ref in ls_ref:\n                        match (ref_path := ProperPath(ref)).kind:\n                            case \"file\" if ref_path.exists():\n                                self._remove_file(_file=ref, verbose=verbose)\n                                # Either FileNotFoundError and PermissionError occurring can mean that\n                                # a dir path was passed when its kind is set as \"file\"\n                            case \"dir\" if not parent_only and ref_path.exists():\n                                rmtree(ref)\n                                # A subdir can delete files inside first, but ls_ref will still have old\n                                # (already copied from ls_ref generator) files/folders,\n                                # hence the ref_path.exists() check to avoid repeated deletions.\n                                self.err_logger.debug(\n                                    f\"Deleted directory (recursively): {ref}\"\n                                ) if verbose else ...\n                                # rmtree deletes files and directories recursively.\n                                # So in case of permission error with rmtree(ref),\n                                # shutil.rmtree() might give better\n                                # traceback message. I.e., which file or directory exactly\n                else:\n                    if not parent_only:\n                        super().rmdir()\n                        self.err_logger.debug(\n                            f\"Deleted empty directory: {self._expanded}\"\n                        ) if verbose else ...\n\n    def open(self, mode=\"r\", encoding=None, *args, **kwargs):\n        \"\"\"\n        ProperPath open first resolves the whole path and then simply returns pathlib.Path.open.\n        This method is mainly overloaded to log exceptions.\n        \"\"\"\n        file = self._expanded\n        try:\n            return Path(file).open(\n                mode=mode,\n                encoding=encoding,\n                *args,\n                **kwargs,\n            )\n        except tuple(OSError.__subclasses__()) as e:\n            self.err_logger.debug(\n                f\"Could not open file {self._error_helper_compare_path_source(self.actual, file)}. \"\n                f\"Exception: {e!r}\"\n            )\n            self.PathException = e\n            raise e\n        except (os_exception := OSError) as e:\n            self.err_logger.debug(\n                f\"Could not open file {self._error_helper_compare_path_source(self.actual, file)}. \"\n                f\"Exception: {e!r}\"\n            )\n            self.PathException = os_exception\n            raise e\n\n    # noinspection PyIncorrectDocstring\n    def get_text(\n        self,\n        encoding: Optional[str] = None,\n        errors: Optional[str] = None,\n        newline: Optional[str] = None,\n        default: Optional[str] = None,\n    ) -&gt; Optional[str]:\n        \"\"\"\n        `get_text` method is basically [`read_text`](https://docs.python.org/3.13/library/pathlib.html#pathlib.Path.read_text)\n        with support for extra `defaults` parameter. `get_text` passes optional arguments `encoding`, `errors`, `newline` to\n        `read_text`.\n\n        Args:\n            encoding: The same meaning as the `encoding` argument for method\n                [`open`](https://docs.python.org/3.13/library/functions.html#open).\n            errors: The same meaning as the `encoding` argument for method\n                [`open`](https://docs.python.org/3.13/library/functions.html#open).\n            newline: The same meaning as the `encoding` argument for method\n                [`open`](https://docs.python.org/3.13/library/functions.html#open).\n                `newline` is only supported in Python 3.13 and above.\n            default:\n                If the file does not exist, then `default` is returned. By default, `default` is `None`.\n\n        Example:\n            ```python\n            import json\n            from properpath import P\n\n            cache = json.loads(P(\"~/.cache/app/cache.json\").get_text(encoding=\"utf-8\", default='{}'))\n            ```\n\n        Returns:\n            The decoded contents of the pointed-to file as a string or default (when file does not exist).\n        \"\"\"\n        try:\n            if sys.version_info.minor &gt;= 13:\n                return super().read_text(encoding, errors, newline)\n            return super().read_text(encoding, errors)\n        except FileNotFoundError:\n            return default\n\n    # noinspection PyIncorrectDocstring\n    def get_bytes(self, default: Optional[bytes] = None) -&gt; Optional[bytes]:\n        \"\"\"\n        `get_bytes` method is basically [`read_bytes`](https://docs.python.org/3.13/library/pathlib.html#pathlib.Path.read_bytes)\n        with support for extra `defaults` parameter.\n\n        Args:\n            default:\n                If the file does not exist, then `default` is returned. By default, `default` is `None`.\n\n        Returns:\n            The binary contents of the pointed-to file as a bytes object or default (when file does not exist).\n        \"\"\"\n        try:\n            return super().read_bytes()\n        except FileNotFoundError:\n            return default\n</code></pre>"},{"location":"apis/properpath/#properpath.ProperPath.actual","title":"actual  <code>property</code> <code>writable</code>","text":"<pre><code>actual: Iterable[str]\n</code></pre> <p>Provides access to the user-given path (or path segments) that was passed to the constructor of the <code>ProperPath</code> instance. <code>ProperPath</code> by default expands any user indicator <code>\"~\"</code> automatically and uses the expanded path for all operations. The <code>actual</code> attribute will reveal the non-expanded original value.</p> Example <pre><code>ProperPath(\"~\", \"foo\").actual\n# Returns (\"~\", \"foo\")\n</code></pre> <p>Returns:</p> Type Description <code>Iterable[str]</code> <p>The path value</p>"},{"location":"apis/properpath/#properpath.ProperPath.kind","title":"kind  <code>property</code> <code>writable</code>","text":"<pre><code>kind: Literal['file', 'dir']\n</code></pre> <p>Retrieves the path kind: a \"file\" or a \"dir\". If the path exists, kind already knows what kind it is. If the path doesn't exist, kind tries to assume the kind from file suffixes. Kind can also handle special files like <code>/dev/null</code>. A <code>kind</code> value ('file' or 'dir') can also be manually passed to the constructor during instance creation or be set later. The user-modified <code>kind</code> is treated as the user expected <code>kind</code>.</p> <p>Returns:</p> Type Description <code>Literal['file', 'dir']</code> <p>\"file\" or \"dir\" depending on the path.</p>"},{"location":"apis/properpath/#properpath.ProperPath.err_logger","title":"err_logger  <code>property</code> <code>writable</code>","text":"<pre><code>err_logger\n</code></pre> <p>Provides access to the error logger that is used for logging exceptions. The default logger is <code>ProperPath.default_err_logger</code>.</p> <p>Returns:</p> Type Description <code>Logger</code> <p>The error logger instance.</p>"},{"location":"apis/properpath/#properpath.ProperPath.PathException","title":"PathException  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<pre><code>PathException: type[Exception] | type[BaseException]\n</code></pre> <p><code>PathException</code> property stores an exception (like <code>OSException</code>) raised for the working path instance, before the exception is raised normally. In some ways, <code>PathException</code> treats errors/exceptions as values. <code>PathException</code> can be used to create design patterns where one path failing doesn't matter, but any path from a list of available paths can be used for the user.</p> Example <pre><code># Storing data to a file of from a list of fallback file paths:\npath_exceptions = []\n\nfor path in [ProperPath(\"/media/usb/file.txt\"), ProperPath(\"~/Downloads/file.txt\")]:\n    try:\n        path.write_text(\"Hello, World!\")\n    except path.PathException as e:\n        # Ignore exception, just try the next path.\n        # Exception is automatically logged by path.err_logger\n        path_exceptions.append(e)\n        continue\n    else:\n        # Write is successful without any error, we exit the loop.\n        break\nelse:\n    # When all paths failed, raise the last exception (or all exceptions).\n    path.err_logger.error(f\"Couldn't write to any of the fallback paths. Exceptions: {path_exceptions}\")\n    raise path.PathException\n</code></pre> <p>Returns:</p> Type Description <code>type[Exception] | type[BaseException]</code> <p>The exception thrown for the working path instance.</p>"},{"location":"apis/properpath/#properpath.ProperPath.__init__","title":"__init__","text":"<pre><code>__init__(*actual: Union[str, Path, ProperPath], kind: Optional[str] = None, err_logger: Optional[Logger] = None)\n</code></pre> <p>Initializes a <code>ProperPath</code> instance. A <code>ProperPath</code> instance can be passed to <code>pathlib.Path</code> and vice versa.</p> <p>Parameters:</p> Name Type Description Default <code>actual</code> <code>Union[str, Path, ProperPath]</code> <p>A collection of paths provided as strings, <code>Path</code> objects, or <code>ProperPath</code> objects that represent the input paths to be processed. This acts just like the first argument passed to <code>pathlib.Path</code>. E.g., <code>ProperPath(\"~\", \"foo\")</code>.</p> <code>()</code> <p>Other Parameters:</p> Name Type Description <code>kind</code> <code>Optional[str]</code> <p>An optional string to indicate if the path is a file or a directory. If it is <code>None</code> (the default), ProperPath will try to determine the kind automatically based on file suffixes and various other patterns.</p> <code>err_logger</code> <code>Optional[Logger]</code> <p>An optional <code>Logger</code> object for handling error logging. If <code>None</code>, the class instance default_err_logger is used.</p> Source code in <code>src/properpath/properpath.py</code> <pre><code>def __init__(\n    self,\n    *actual: Union[str, Path, \"ProperPath\"],\n    kind: Optional[str] = None,  # Here, None =&gt; Undefined/unknown\n    err_logger: Optional[logging.Logger] = None,\n):\n    \"\"\"\n    Initializes a `ProperPath` instance. A `ProperPath` instance can be passed to `pathlib.Path` and vice versa.\n\n    Args:\n        actual (Union[str, Path, \"ProperPath\"]): A collection of paths provided as strings, `Path` objects,\n            or `ProperPath` objects that represent the input paths to be processed.\n            This acts just like the first argument passed to `pathlib.Path`.\n            E.g., `ProperPath(\"~\", \"foo\")`.\n\n    Keyword Args:\n        kind (Optional[str]): An optional string to indicate if the path is a file or a directory. If it is `None` (the default),\n            ProperPath will try to determine the kind automatically based on file suffixes and various other patterns.\n        err_logger (Optional[logging.Logger]): An optional `Logger` object for handling error logging.\n            If `None`, the class instance default_err_logger is used.\n    \"\"\"\n\n    self._user_expects_kind: bool\n    self._kind: Literal[\"file\", \"dir\"] | None\n    self.actual = actual\n    super().__init__(self._expanded)\n    self.kind = kind\n    self.err_logger = err_logger or ProperPath.default_err_logger\n    self.PathException = NoException\n</code></pre>"},{"location":"apis/properpath/#properpath.ProperPath.platformdirs","title":"platformdirs  <code>classmethod</code>","text":"<pre><code>platformdirs(appname: Optional[str] = None, appauthor: str | Literal[False] | None = None, version: Optional[str] = None, roaming: bool = False, multipath: bool = False, opinion: bool = True, ensure_exists: bool = False, follow_unix: bool = False) -&gt; ProperPlatformDirs\n</code></pre> <p>Initializes and returns a <code>platformdirs.PlatformDirs</code> instance.</p> <p>Provides appropriate platform-specific application directories (e.g., OS-standard location for configuration files, logs, shared files, caches, etc.). See platformdirs documentation for more details: https://github.com/tox-dev/platformdirs</p> <p>platformdirs doesn't offer a way to get Unix-like directories on macOS which may not be always desired. So, <code>ProperPath.platformdirs</code> offers an additional argument <code>follow_unix</code>, which is False by default. If <code>follow_unix</code> is True, <code>ProperPath.platformdirs</code> will return an instance that follows a Unix-like directory structure for both macOS and Linux-based operating systems. Windows paths will not be altered.</p> Example <pre><code>app_dirs = ProperPath.platformdirs(\"MyApp\", \"MyOrg\")\napp_dirs.user_data_dir\n# Returns ProperPath('/Users/user/Library/Application Support/MyApp')\n\n# Use Unix-like paths on macOS\napp_dirs = ProperPath.platformdirs(\"MyApp\", follow_unix=True)\napp_dirs.user_data_dir\n# Returns a Unix-style path even on macOS: ProperPath('/home/user/.local/share/MyApp\n\n# With additional arguments for platformdirs.PlatformDirs\ndirs = ProperPath.platformdirs(\"MyApp\", version=\"1.0\", roaming=True)\ndirs.user_config_dir\n# Returns ProperPath('/Users/user/Library/Application Support/MyApp/1.0')\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>appname</code> <code>Optional[str]</code> <p>The name of the app author or distributing body for this application.</p> <code>None</code> <code>appauthor</code> <code>str | Literal[False] | None</code> <p>Typically, it is the owning company name. Defaults to <code>appname</code>. You may pass <code>False</code> to disable it.</p> <code>None</code> <code>version</code> <code>Optional[str]</code> <p>An optional version path element to append to the path. You might want to use this if you want multiple versions of your app to be able to run independently. If used, this would typically be <code>&lt;major&gt;.&lt;minor&gt;</code>.</p> <code>None</code> <code>roaming</code> <code>bool</code> <p>Whether to use the roaming appdata directory on Windows. That means that for users on a Windows network setup for roaming profiles, this user data will be synced on login. See: https://technet.microsoft.com/en-us/library/cc766489(WS.10).aspx</p> <code>False</code> <code>multipath</code> <code>bool</code> <p>An optional parameter which indicates that the entire list of data dirs should be returned. By default, the first item would only be returned.</p> <code>False</code> <code>opinion</code> <code>bool</code> <p>A flag to indicating to use opinionated values.</p> <code>True</code> <code>ensure_exists</code> <code>bool</code> <p>Optionally create the directory (and any missing parents) upon access if it does not exist. By default, no directories are created.</p> <code>False</code> <code>follow_unix</code> <code>bool</code> <p>Specifies whether to enforce a Unix-like directory structure for both macOS and Linux. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>PlatformDirs</code> <p>An instance of the appropriate platform directory handler</p> Source code in <code>src/properpath/properpath.py</code> <pre><code>@classmethod\ndef platformdirs(\n    cls,\n    appname: Optional[str] = None,\n    appauthor: str | Literal[False] | None = None,\n    version: Optional[str] = None,\n    roaming: bool = False,\n    multipath: bool = False,\n    opinion: bool = True,\n    ensure_exists: bool = False,\n    follow_unix: bool = False,\n) -&gt; ProperPlatformDirs:\n    \"\"\"\n    Initializes and returns a `platformdirs.PlatformDirs` instance.\n\n    Provides appropriate platform-specific application directories (e.g., OS-standard\n    location for configuration files, logs, shared files, caches, etc.).\n    See platformdirs documentation for more details: https://github.com/tox-dev/platformdirs\n\n    platformdirs doesn't offer a way to get Unix-like directories on macOS which may not\n    be always desired. So, `ProperPath.platformdirs` offers an additional argument\n    `follow_unix`, which is False by default. If `follow_unix` is True,\n    `ProperPath.platformdirs` will return an instance that follows a Unix-like directory\n    structure for both macOS and Linux-based operating systems. Windows paths will not\n    be altered.\n\n\n    Example:\n        ```python  hl_lines=\"3 8 13\"\n        app_dirs = ProperPath.platformdirs(\"MyApp\", \"MyOrg\")\n        app_dirs.user_data_dir\n        # Returns ProperPath('/Users/user/Library/Application Support/MyApp')\n\n        # Use Unix-like paths on macOS\n        app_dirs = ProperPath.platformdirs(\"MyApp\", follow_unix=True)\n        app_dirs.user_data_dir\n        # Returns a Unix-style path even on macOS: ProperPath('/home/user/.local/share/MyApp\n\n        # With additional arguments for platformdirs.PlatformDirs\n        dirs = ProperPath.platformdirs(\"MyApp\", version=\"1.0\", roaming=True)\n        dirs.user_config_dir\n        # Returns ProperPath('/Users/user/Library/Application Support/MyApp/1.0')\n        ```\n\n    Args:\n        appname (Optional[str]): The name of the app author or distributing body for this application.\n        appauthor (str | Literal[False] | None): Typically, it is the owning company name. Defaults to `appname`.\n            You may pass ``False`` to disable it.\n        version (Optional[str]): An optional version path element to append to the path.\n            You might want to use this if you want multiple versions of your app to be\n            able to run independently. If used, this would typically be ``&lt;major&gt;.&lt;minor&gt;``.\n        roaming (bool): Whether to use the roaming appdata directory on Windows.\n            That means that for users on a Windows network setup for roaming profiles,\n            this user data will be synced on login.\n            See: https://technet.microsoft.com/en-us/library/cc766489(WS.10).aspx\n        multipath (bool): An optional parameter which indicates that the entire list of data\n            dirs should be returned. By default, the first item would only be returned.\n        opinion (bool): A flag to indicating to use opinionated values.\n        ensure_exists (bool): Optionally create the directory (and any missing parents) upon\n            access if it does not exist. By default, no directories are created.\n        follow_unix (bool): Specifies whether to enforce a Unix-like directory structure\n            for both macOS and Linux. Defaults to False.\n\n    Returns:\n        (PlatformDirs): An instance of the appropriate platform directory handler\n    \"\"\"\n\n    dirs: ProperPlatformDirs | ProperUnix\n    if follow_unix is True:\n        if sys.platform == \"darwin\":\n            dirs = ProperUnix(\n                appname,\n                appauthor,\n                version,\n                roaming,\n                multipath,\n                opinion,\n                ensure_exists,\n                path_cls=cls,\n            )\n        else:\n            dirs = ProperPlatformDirs(\n                appname,\n                appauthor,\n                version,\n                roaming,\n                multipath,\n                opinion,\n                ensure_exists,\n                path_cls=cls,\n            )\n    else:\n        dirs = ProperPlatformDirs(\n            appname,\n            appauthor,\n            version,\n            roaming,\n            multipath,\n            opinion,\n            ensure_exists,\n            path_cls=cls,\n        )\n    return dirs\n</code></pre>"},{"location":"apis/properpath/#properpath.ProperPath.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>An information-rich representation of the ProperPath instance.</p> Source code in <code>src/properpath/properpath.py</code> <pre><code>def __repr__(self):\n    \"\"\"\n    Returns:\n        (str): An information-rich representation of the ProperPath instance.\n    \"\"\"\n    return (\n        f\"{self.__class__.__name__}(path={self}, actual={self.actual}, \"\n        f\"kind={self.kind}, exists={self.exists()}, is_symlink={self.is_symlink()}, \"\n        f\"err_logger={self.err_logger})\"\n    )\n</code></pre>"},{"location":"apis/properpath/#properpath.ProperPath.__rich_repr__","title":"__rich_repr__","text":"<pre><code>__rich_repr__()\n</code></pre> <p>Enables rich repr support. See rich REPR protocol documentation.</p> Source code in <code>src/properpath/properpath.py</code> <pre><code>def __rich_repr__(self):\n    \"\"\"\n    Enables rich __repr__ support.\n    See [rich REPR protocol documentation](https://rich.readthedocs.io/en/latest/pretty.html#rich-repr-protocol).\n    \"\"\"\n    yield \"path\", str(self)\n    yield \"actual\", self.actual\n    yield \"kind\", self.kind\n    yield \"exists\", self.exists()\n    yield \"is_symlink\", self.is_symlink()\n    yield \"err_logger\", self.err_logger\n</code></pre>"},{"location":"apis/properpath/#properpath.ProperPath.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memo)\n</code></pre> <p><code>ProperPath</code>, likely due to being a victim of inheritance hell, can throw odd errors when it is deepcopied as a namedtuple. The <code>__deepcopy__</code> method is overridden to avoid that.</p> Note <p>If you're getting <code>AttributeError: 'properpath.properpath.ProperPath' object has no attribute '_raw_paths'. Did you mean: '_raw_path'?</code>, it likely has something to do with <code>__deepcopy__</code> even if it doesn't show up in the traceback.</p> <p>Parameters:</p> Name Type Description Default <code>memo</code> required Source code in <code>src/properpath/properpath.py</code> <pre><code>def __deepcopy__(self, memo):\n    \"\"\"\n    `ProperPath`, likely due to being a victim of inheritance hell, can throw odd errors when it is deepcopied\n    as a namedtuple. The `__deepcopy__` method is overridden to avoid that.\n\n    Note:\n        If you're getting `AttributeError: 'properpath.properpath.ProperPath' object has no attribute '_raw_paths'.\n        Did you mean: '_raw_path'?`, it likely has something to do with `__deepcopy__` even if\n        it doesn't show up in the traceback.\n\n    Args:\n        memo:\n    \"\"\"\n    if memo_instance := memo.get(id(self)):\n        return memo_instance\n    instance = self.__class__(self)\n    memo[id(self)] = instance\n    instance.__dict__.update(deepcopy(self.__dict__, memo))\n    return instance\n</code></pre>"},{"location":"apis/properpath/#properpath.ProperPath.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(source_type: Any, handler: Any)\n</code></pre> <p>Enables Pydantic validation support. See Pydantic documentation.</p> Source code in <code>src/properpath/properpath.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(cls, source_type: Any, handler: Any):\n    \"\"\"\n    Enables Pydantic validation support.\n    See [Pydantic documentation](https://docs.pydantic.dev/latest/concepts/types/#customizing-validation-with-__get_pydantic_core_schema__).\n    \"\"\"\n    return _get_pydantic_core_schema(cls, source_type, handler)\n</code></pre>"},{"location":"apis/properpath/#properpath.ProperPath.create","title":"create","text":"<pre><code>create(verbose: bool = True) -&gt; None\n</code></pre> <p>Creates a file or directory based on the specified kind (file or dir). Thanks to the property <code>kind</code>, the <code>create</code> method helps to avoid writing boilerplate code like <code>if path.is_file()</code> or <code>path.is_dir()</code>. For files and directories, it ensures the parent directory exists before creating the file. Logs operations and exceptions for debugging.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>If True, debug logs will be generated to trace creation attempts for files and directories.</p> <code>True</code> <p>Raises:</p> Type Description <code>PermissionError</code> <p>If the operation lacks permission to create the file or directory.</p> <code>NotADirectoryError</code> <p>If the operation attempts to create a directory under a path that is incorrectly treated as a non-directory.</p> <code>OSError</code> <p>If an OS-level error (all others excluding <code>PermissionError</code> and <code>NotADirectoryError</code>) occurs during the creation process.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/properpath/properpath.py</code> <pre><code>def create(self, verbose: bool = True) -&gt; None:\n    \"\"\"\n    Creates a file or directory based on the specified kind (file or dir). Thanks to the property `kind`,\n    the `create` method helps to avoid writing boilerplate code like `if path.is_file()`\n    or `path.is_dir()`. For files and directories, it ensures the parent directory exists\n    before creating the file. Logs operations and exceptions for debugging.\n\n    Args:\n        verbose (bool): If True, debug logs will be generated to trace creation\n            attempts for files and directories.\n\n    Raises:\n        PermissionError: If the operation lacks permission to create the file\n            or directory.\n        NotADirectoryError: If the operation attempts to create a directory\n            under a path that is incorrectly treated as a non-directory.\n        OSError: If an OS-level error (all others excluding `PermissionError` and\n            `NotADirectoryError`) occurs during the creation process.\n\n    Returns:\n        None\n    \"\"\"\n    path = super().resolve(strict=False)\n    try:\n        match self.kind:\n            case \"file\":\n                path_parent, path_file = path.parent, path.name\n                if not path_parent.exists() and verbose:\n                    self.err_logger.debug(\n                        f\"File {self._error_helper_compare_path_source(self.actual, path_parent)} \"\n                        f\"could not be found. An attempt to create file \"\n                        f\"{path_parent} will be made.\"\n                    )\n                path_parent.mkdir(parents=True, exist_ok=True)\n                (path_parent / path_file).touch(exist_ok=True)\n                if not (path_parent / path_file).is_file():\n                    is_a_dir_exception = IsADirectoryError\n                    message = (\n                        \"File was expected but a directory with the same name was found: \"\n                        f\"{self._error_helper_compare_path_source(self.actual, path_parent)}. \"\n                    )\n                    self.err_logger.debug(message)\n                    raise is_a_dir_exception(message)\n            case \"dir\":\n                if not path.exists() and verbose:\n                    self.err_logger.debug(\n                        f\"Directory {self._error_helper_compare_path_source(self.actual, path)} \"\n                        f\"could not be found. An attempt to create directory \"\n                        f\"{path} will be made.\"\n                    )\n                path.mkdir(parents=True, exist_ok=True)\n    except (permission_exception := PermissionError) as e:\n        message = f\"Permission to create {self._error_helper_compare_path_source(self.actual, path)} is denied.\"\n        self.err_logger.debug(message)\n        self.PathException = permission_exception\n        raise e\n    except tuple(OSError.__subclasses__()) as e:\n        self.err_logger.debug(\n            f\"Could not create {self._error_helper_compare_path_source(self.actual, path)}. \"\n            f\"Exception: {e!r}\"\n        )\n        self.PathException = e\n        raise e\n    except (os_exception := OSError) as os_err:\n        # When an attempt to create a file or directory inside root (e.g., '/foo')\n        # is made, OS can throw OSError with error no. 30 instead of PermissionError.\n        self.err_logger.debug(\n            f\"Could not create {self._error_helper_compare_path_source(self.actual, path)}. \"\n            f\"Exception: {os_err!r}\"\n        )\n        self.PathException = os_exception\n        raise os_err\n</code></pre>"},{"location":"apis/properpath/#properpath.ProperPath.remove","title":"remove","text":"<pre><code>remove(parent_only: bool = False, verbose: bool = True) -&gt; None\n</code></pre> <p>Removes the <code>ProperPath</code> file or directory based on the specified parameters. The method removes either all contents of a directory path or a single file, depending on the type of the path (file or directory). If <code>parent_only</code> is True, only top-level contents are removed while keeping the parent directory intact. If <code>parent_only</code> is False, all contents are removed recursively. <code>verbose</code> can be passed <code>False</code> (default is <code>True</code>) to disable logging the removals.</p> <p>Parameters:</p> Name Type Description Default <code>parent_only</code> <code>bool</code> <p>A boolean flag indicating whether only the immediate children of the directory should be removed, leaving the parent directory intact. Defaults to <code>False</code>.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>A boolean flag indicating whether detailed logs of the removal operations should be printed or logged. Defaults to <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/properpath/properpath.py</code> <pre><code>def remove(self, parent_only: bool = False, verbose: bool = True) -&gt; None:\n    \"\"\"\n    Removes the `ProperPath` file or directory based on the specified parameters. The method\n    removes either all contents of a directory path or a single file, depending on the type of\n    the path (file or directory). If `parent_only` is True, only top-level contents are removed\n    while keeping the parent directory intact. If `parent_only` is False, all contents are\n    removed recursively. `verbose` can be passed `False` (default is `True`) to disable logging\n    the removals.\n\n    Args:\n        parent_only (bool): A boolean flag indicating whether only the immediate children of the\n            directory should be removed, leaving the parent directory intact. Defaults to `False`.\n        verbose (bool): A boolean flag indicating whether detailed logs of the removal operations\n            should be printed or logged. Defaults to `True`.\n\n    Returns:\n        None\n    \"\"\"\n    # removes everything (if parent_only is False) found inside a ProperPath except the parent directory of the path\n    # if the ProperPath isn't a directory, then it just removes the file\n    match self.kind:\n        case \"file\":\n            self._remove_file(verbose=verbose)\n        case \"dir\":\n            ls_ref: Iterable[Path]\n            ls_ref = (\n                super().glob(r\"**/*\") if not parent_only else super().glob(r\"*\")\n            )\n            ls_ref = list(ls_ref)\n            if ls_ref:\n                for ref in ls_ref:\n                    match (ref_path := ProperPath(ref)).kind:\n                        case \"file\" if ref_path.exists():\n                            self._remove_file(_file=ref, verbose=verbose)\n                            # Either FileNotFoundError and PermissionError occurring can mean that\n                            # a dir path was passed when its kind is set as \"file\"\n                        case \"dir\" if not parent_only and ref_path.exists():\n                            rmtree(ref)\n                            # A subdir can delete files inside first, but ls_ref will still have old\n                            # (already copied from ls_ref generator) files/folders,\n                            # hence the ref_path.exists() check to avoid repeated deletions.\n                            self.err_logger.debug(\n                                f\"Deleted directory (recursively): {ref}\"\n                            ) if verbose else ...\n                            # rmtree deletes files and directories recursively.\n                            # So in case of permission error with rmtree(ref),\n                            # shutil.rmtree() might give better\n                            # traceback message. I.e., which file or directory exactly\n            else:\n                if not parent_only:\n                    super().rmdir()\n                    self.err_logger.debug(\n                        f\"Deleted empty directory: {self._expanded}\"\n                    ) if verbose else ...\n</code></pre>"},{"location":"apis/properpath/#properpath.ProperPath.open","title":"open","text":"<pre><code>open(mode='r', encoding=None, *args, **kwargs)\n</code></pre> <p>ProperPath open first resolves the whole path and then simply returns pathlib.Path.open. This method is mainly overloaded to log exceptions.</p> Source code in <code>src/properpath/properpath.py</code> <pre><code>def open(self, mode=\"r\", encoding=None, *args, **kwargs):\n    \"\"\"\n    ProperPath open first resolves the whole path and then simply returns pathlib.Path.open.\n    This method is mainly overloaded to log exceptions.\n    \"\"\"\n    file = self._expanded\n    try:\n        return Path(file).open(\n            mode=mode,\n            encoding=encoding,\n            *args,\n            **kwargs,\n        )\n    except tuple(OSError.__subclasses__()) as e:\n        self.err_logger.debug(\n            f\"Could not open file {self._error_helper_compare_path_source(self.actual, file)}. \"\n            f\"Exception: {e!r}\"\n        )\n        self.PathException = e\n        raise e\n    except (os_exception := OSError) as e:\n        self.err_logger.debug(\n            f\"Could not open file {self._error_helper_compare_path_source(self.actual, file)}. \"\n            f\"Exception: {e!r}\"\n        )\n        self.PathException = os_exception\n        raise e\n</code></pre>"},{"location":"apis/properpath/#properpath.ProperPath.get_text","title":"get_text","text":"<pre><code>get_text(encoding: Optional[str] = None, errors: Optional[str] = None, newline: Optional[str] = None, default: Optional[str] = None) -&gt; Optional[str]\n</code></pre> <p><code>get_text</code> method is basically <code>read_text</code> with support for extra <code>defaults</code> parameter. <code>get_text</code> passes optional arguments <code>encoding</code>, <code>errors</code>, <code>newline</code> to <code>read_text</code>.</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>Optional[str]</code> <p>The same meaning as the <code>encoding</code> argument for method <code>open</code>.</p> <code>None</code> <code>errors</code> <code>Optional[str]</code> <p>The same meaning as the <code>encoding</code> argument for method <code>open</code>.</p> <code>None</code> <code>newline</code> <code>Optional[str]</code> <p>The same meaning as the <code>encoding</code> argument for method <code>open</code>. <code>newline</code> is only supported in Python 3.13 and above.</p> <code>None</code> <code>default</code> <code>Optional[str]</code> <p>If the file does not exist, then <code>default</code> is returned. By default, <code>default</code> is <code>None</code>.</p> <code>None</code> Example <pre><code>import json\nfrom properpath import P\n\ncache = json.loads(P(\"~/.cache/app/cache.json\").get_text(encoding=\"utf-8\", default='{}'))\n</code></pre> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The decoded contents of the pointed-to file as a string or default (when file does not exist).</p> Source code in <code>src/properpath/properpath.py</code> <pre><code>def get_text(\n    self,\n    encoding: Optional[str] = None,\n    errors: Optional[str] = None,\n    newline: Optional[str] = None,\n    default: Optional[str] = None,\n) -&gt; Optional[str]:\n    \"\"\"\n    `get_text` method is basically [`read_text`](https://docs.python.org/3.13/library/pathlib.html#pathlib.Path.read_text)\n    with support for extra `defaults` parameter. `get_text` passes optional arguments `encoding`, `errors`, `newline` to\n    `read_text`.\n\n    Args:\n        encoding: The same meaning as the `encoding` argument for method\n            [`open`](https://docs.python.org/3.13/library/functions.html#open).\n        errors: The same meaning as the `encoding` argument for method\n            [`open`](https://docs.python.org/3.13/library/functions.html#open).\n        newline: The same meaning as the `encoding` argument for method\n            [`open`](https://docs.python.org/3.13/library/functions.html#open).\n            `newline` is only supported in Python 3.13 and above.\n        default:\n            If the file does not exist, then `default` is returned. By default, `default` is `None`.\n\n    Example:\n        ```python\n        import json\n        from properpath import P\n\n        cache = json.loads(P(\"~/.cache/app/cache.json\").get_text(encoding=\"utf-8\", default='{}'))\n        ```\n\n    Returns:\n        The decoded contents of the pointed-to file as a string or default (when file does not exist).\n    \"\"\"\n    try:\n        if sys.version_info.minor &gt;= 13:\n            return super().read_text(encoding, errors, newline)\n        return super().read_text(encoding, errors)\n    except FileNotFoundError:\n        return default\n</code></pre>"},{"location":"apis/properpath/#properpath.ProperPath.get_bytes","title":"get_bytes","text":"<pre><code>get_bytes(default: Optional[bytes] = None) -&gt; Optional[bytes]\n</code></pre> <p><code>get_bytes</code> method is basically <code>read_bytes</code> with support for extra <code>defaults</code> parameter.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Optional[bytes]</code> <p>If the file does not exist, then <code>default</code> is returned. By default, <code>default</code> is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[bytes]</code> <p>The binary contents of the pointed-to file as a bytes object or default (when file does not exist).</p> Source code in <code>src/properpath/properpath.py</code> <pre><code>def get_bytes(self, default: Optional[bytes] = None) -&gt; Optional[bytes]:\n    \"\"\"\n    `get_bytes` method is basically [`read_bytes`](https://docs.python.org/3.13/library/pathlib.html#pathlib.Path.read_bytes)\n    with support for extra `defaults` parameter.\n\n    Args:\n        default:\n            If the file does not exist, then `default` is returned. By default, `default` is `None`.\n\n    Returns:\n        The binary contents of the pointed-to file as a bytes object or default (when file does not exist).\n    \"\"\"\n    try:\n        return super().read_bytes()\n    except FileNotFoundError:\n        return default\n</code></pre>"},{"location":"apis/properpath/#other-pathlibpath-methods-and-attributes","title":"Other <code>pathlib.Path</code> methods and attributes","text":"<p>As a subclass of <code>pathlib.Path</code>, a <code>properpath</code> instance supports all other  <code>pathlib.Path</code> methods and attributes that are not listed here.</p>"},{"location":"apis/properpath/#p","title":"<code>P</code>","text":"<p><code>P</code> is an alias for <code>ProperPath</code>. <code>P</code> is the preferred way to import <code>ProperPath</code> as it is much shorter and easier to type.</p> <pre><code>from properpath import P, ProperPath\n\nassert P == ProperPath\n</code></pre>"},{"location":"apis/validators/","title":"Path Validators","text":""},{"location":"apis/validators/#properpath.validators.Validator","title":"Validator","text":"<p>               Bases: <code>ABC</code></p> <p>The abstract base class for validators.</p> Source code in <code>src/properpath/validators/base.py</code> <pre><code>class Validator(ABC):\n    \"\"\"\n    The abstract base class for validators.\n    \"\"\"\n\n    @abstractmethod\n    def validate(self, *args, **kwargs): ...\n</code></pre>"},{"location":"apis/validators/#properpath.validators.PathValidationError","title":"PathValidationError","text":"<p>               Bases: <code>ValidationError</code></p> <p>Represents a specialized exception raised for path validation errors.</p> <p><code>PathValidationError</code> is raised when a path validator (Validator subclass) fails to validate a given path(s). Unlike in <code>OSError</code>, the errno is defined as an instance attribute rather than a class attribute. This is to indicate that each path validation is tied to that path only.</p> <p>Attributes:</p> Name Type Description <code>errno</code> <code>Optional[int]</code> <p>The erOSError number associated with the path validation error.</p> Source code in <code>src/properpath/validators/validators.py</code> <pre><code>class PathValidationError(ValidationError):\n    \"\"\"\n    Represents a specialized exception raised for path validation errors.\n\n    `PathValidationError` is raised when a path validator (Validator subclass) fails to validate\n    a given path(s). Unlike in `OSError`, the errno is defined as an instance attribute rather\n    than a class attribute. This is to indicate that each path validation is tied to that path only.\n\n    Attributes:\n        errno (Optional[int]): The erOSError number associated with the path validation error.\n    \"\"\"\n\n    def __init__(self, *args) -&gt; None:\n        super().__init__(*args)\n        self.errno: Optional[int] = None\n        # Unlike OSError, errno here is an instance attribute\n        # instead of being a class attribute.\n        # This will ensure broad use of errno with PathValidationError in the future.\n\n    def __call__(self, *args) -&gt; Self:\n        super().__init__(*args)\n        return self\n</code></pre>"},{"location":"apis/validators/#properpath.validators.PathWriteValidator","title":"PathWriteValidator","text":"<p>               Bases: <code>Validator</code></p> <p><code>PathWriteValidator</code> does validation for given paths to make sure they are writable.</p> <p><code>PathWriteValidator</code> constructor accepts a single path instance or an iterable of path instances. If the given path is a file (<code>kind == \"file\"</code>), PathWriteValidator will create the file (if it doesn't already exist), then write a control character to the file and delete the character immediately after. If all this passes without errors, the file is considered to be successfully validated and is returned. If a directory is given, a temporary file is created inside the directory to validate write permissions. If an iterable of paths is given, the first path that passes validation is returned.</p> Example <pre><code>user_download_paths = [\"/mnt/usb/Downloads\", \"~/Downloads\"]\ntry:\n    path = PathWriteValidator(user_download_paths).validate()\nexcept PathValidationError as e:\n    raise e(\"All paths are not writable!\")\nelse:\n    # Do something with the validated path.\n    path.write_text(\"...\")\n</code></pre> Source code in <code>src/properpath/validators/validators.py</code> <pre><code>class PathWriteValidator(Validator):\n    \"\"\"\n    `PathWriteValidator` does validation for given paths to make sure they are writable.\n\n    `PathWriteValidator` constructor accepts a single path instance or an iterable of path instances.\n    If the given path is a file (`kind == \"file\"`), PathWriteValidator will create the file\n    (if it doesn't already exist), then write a control character to the file and delete the character immediately after.\n    If all this passes without errors, the file is considered to be successfully validated and is returned.\n    If a directory is given, a temporary file is created inside the directory to validate write\n    permissions. If an iterable of paths is given, the first path that passes validation is returned.\n\n    Example:\n        ```python\n        user_download_paths = [\"/mnt/usb/Downloads\", \"~/Downloads\"]\n        try:\n            path = PathWriteValidator(user_download_paths).validate()\n        except PathValidationError as e:\n            raise e(\"All paths are not writable!\")\n        else:\n            # Do something with the validated path.\n            path.write_text(\"...\")\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        path: Union[Iterable[str | ProperPath | Path], Union[str, ProperPath, Path]],\n        retain_created_file: bool = True,\n        err_logger: Optional[logging.Logger] = None,\n    ):\n        \"\"\"\n        Initializes the class with the provided paths, an option to retain the created\n        temporary files, and an optional error logger. The instance maintains these\n        parameters throughout its lifecycle.\n\n        Args:\n            path (Union[Iterable[str | ProperPath | Path], Union[str, ProperPath, Path]]): An iterable or individual value representing paths. It can include\n                strings, ProperPath objects, or Path objects.\n\n        Keyword Args:\n            retain_created_file (bool): Flag indicating whether created files (if the given file path already\n                doesn't exist) during validation should be retained. Defaults to `True`.\n            err_logger (Optional[logging.Logger]): An optional Logger object used for logging errors. If not\n                provided, a default error logger will be set.\n        \"\"\"\n        self.path = path\n        self.err_logger = err_logger or ProperPath.default_err_logger\n        self._tmp_file = (\n            f\".tmp_{''.join(choices(string.ascii_lowercase + string.digits, k=16))}\"\n        )\n        self.retain_created_file = retain_created_file\n        self.__self_created_files: list = []\n\n    @property\n    def path(self) -&gt; Iterable[str | ProperPath | Path]:\n        return self._path\n\n    @path.setter\n    def path(self, value):\n        if not isinstance(value, (str, NoneType, ProperPath, Path, Iterable)):\n            raise ValueError(\n                f\"{value} must be an instance (or iterable of \"\n                f\"instances) of str, ProperPath, Path\"\n            )\n        try:\n            iter(value)\n        except TypeError:\n            self._path = (value,)\n        else:\n            self._path = (value,) if isinstance(value, str) else value\n\n    @property\n    def _self_created_files(self):\n        return self.__self_created_files\n\n    def validate(self) -&gt; ProperPath:\n        \"\"\"\n        Returns:\n            (ProperPath): A validated `ProperPath` instance.\n\n        Raises:\n            (PathValidationError): If no path from the given list of paths can be validated.\n\n        \"\"\"\n        errno: Optional[int] = None\n        _self_created_file: bool = False\n        for p in self.path:\n            if not isinstance(p, ProperPath):\n                try:\n                    p = ProperPath(p, err_logger=self.err_logger)\n                except (ValueError, TypeError):\n                    continue\n            p_child = (\n                ProperPath(p / self._tmp_file, kind=\"file\", err_logger=self.err_logger)\n                if p.kind == \"dir\"\n                else p\n            )\n            try:\n                if not p.exists():\n                    p.create()\n                    self._self_created_files.append(p)\n                    _self_created_file = True\n                with p_child.open(mode=\"ba+\") as f:\n                    f.write(\n                        b\"\\x06\"\n                    )  # Throwback: \\x06 is the ASCII \"Acknowledge\" character\n                    f.seek(f.tell() - 1)\n                    if (\n                        not f.read(1) == b\"\\x06\"\n                    ):  # This checks for /dev/null-type special files!\n                        continue  # It'd not be possible to read from those files.\n                    f.seek(f.tell() - 1)\n                    f.truncate()\n            except (\n                p.PathException,\n                p_child.PathException,\n                ValueError,\n                AttributeError,\n            ) as e:\n                errno = getattr(e, \"errno\", None)\n                continue\n            else:\n                if p.kind == \"dir\":\n                    p_child.remove(verbose=False)\n                if (\n                    not self.retain_created_file\n                    and _self_created_file\n                    and p.kind == \"file\"\n                    and p.stat().st_size == 0\n                ):\n                    p.remove()\n                return p\n        validation_error = PathValidationError()\n        validation_error.errno = errno\n        raise validation_error(\"Given path(s) could not be validated!\")\n</code></pre>"},{"location":"apis/validators/#properpath.validators.PathWriteValidator.__init__","title":"__init__","text":"<pre><code>__init__(path: Union[Iterable[str | ProperPath | Path], Union[str, ProperPath, Path]], retain_created_file: bool = True, err_logger: Optional[Logger] = None)\n</code></pre> <p>Initializes the class with the provided paths, an option to retain the created temporary files, and an optional error logger. The instance maintains these parameters throughout its lifecycle.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[Iterable[str | ProperPath | Path], Union[str, ProperPath, Path]]</code> <p>An iterable or individual value representing paths. It can include strings, ProperPath objects, or Path objects.</p> required <p>Other Parameters:</p> Name Type Description <code>retain_created_file</code> <code>bool</code> <p>Flag indicating whether created files (if the given file path already doesn't exist) during validation should be retained. Defaults to <code>True</code>.</p> <code>err_logger</code> <code>Optional[Logger]</code> <p>An optional Logger object used for logging errors. If not provided, a default error logger will be set.</p> Source code in <code>src/properpath/validators/validators.py</code> <pre><code>def __init__(\n    self,\n    path: Union[Iterable[str | ProperPath | Path], Union[str, ProperPath, Path]],\n    retain_created_file: bool = True,\n    err_logger: Optional[logging.Logger] = None,\n):\n    \"\"\"\n    Initializes the class with the provided paths, an option to retain the created\n    temporary files, and an optional error logger. The instance maintains these\n    parameters throughout its lifecycle.\n\n    Args:\n        path (Union[Iterable[str | ProperPath | Path], Union[str, ProperPath, Path]]): An iterable or individual value representing paths. It can include\n            strings, ProperPath objects, or Path objects.\n\n    Keyword Args:\n        retain_created_file (bool): Flag indicating whether created files (if the given file path already\n            doesn't exist) during validation should be retained. Defaults to `True`.\n        err_logger (Optional[logging.Logger]): An optional Logger object used for logging errors. If not\n            provided, a default error logger will be set.\n    \"\"\"\n    self.path = path\n    self.err_logger = err_logger or ProperPath.default_err_logger\n    self._tmp_file = (\n        f\".tmp_{''.join(choices(string.ascii_lowercase + string.digits, k=16))}\"\n    )\n    self.retain_created_file = retain_created_file\n    self.__self_created_files: list = []\n</code></pre>"},{"location":"apis/validators/#properpath.validators.PathWriteValidator.validate","title":"validate","text":"<pre><code>validate() -&gt; ProperPath\n</code></pre> <p>Returns:</p> Type Description <code>ProperPath</code> <p>A validated <code>ProperPath</code> instance.</p> <p>Raises:</p> Type Description <code>PathValidationError</code> <p>If no path from the given list of paths can be validated.</p> Source code in <code>src/properpath/validators/validators.py</code> <pre><code>def validate(self) -&gt; ProperPath:\n    \"\"\"\n    Returns:\n        (ProperPath): A validated `ProperPath` instance.\n\n    Raises:\n        (PathValidationError): If no path from the given list of paths can be validated.\n\n    \"\"\"\n    errno: Optional[int] = None\n    _self_created_file: bool = False\n    for p in self.path:\n        if not isinstance(p, ProperPath):\n            try:\n                p = ProperPath(p, err_logger=self.err_logger)\n            except (ValueError, TypeError):\n                continue\n        p_child = (\n            ProperPath(p / self._tmp_file, kind=\"file\", err_logger=self.err_logger)\n            if p.kind == \"dir\"\n            else p\n        )\n        try:\n            if not p.exists():\n                p.create()\n                self._self_created_files.append(p)\n                _self_created_file = True\n            with p_child.open(mode=\"ba+\") as f:\n                f.write(\n                    b\"\\x06\"\n                )  # Throwback: \\x06 is the ASCII \"Acknowledge\" character\n                f.seek(f.tell() - 1)\n                if (\n                    not f.read(1) == b\"\\x06\"\n                ):  # This checks for /dev/null-type special files!\n                    continue  # It'd not be possible to read from those files.\n                f.seek(f.tell() - 1)\n                f.truncate()\n        except (\n            p.PathException,\n            p_child.PathException,\n            ValueError,\n            AttributeError,\n        ) as e:\n            errno = getattr(e, \"errno\", None)\n            continue\n        else:\n            if p.kind == \"dir\":\n                p_child.remove(verbose=False)\n            if (\n                not self.retain_created_file\n                and _self_created_file\n                and p.kind == \"file\"\n                and p.stat().st_size == 0\n            ):\n                p.remove()\n            return p\n    validation_error = PathValidationError()\n    validation_error.errno = errno\n    raise validation_error(\"Given path(s) could not be validated!\")\n</code></pre>"}]}